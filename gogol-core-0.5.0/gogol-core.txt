-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core data types and functionality for Gogol libraries.
--   
--   Core data types, functionality and serialisation primitives for Gogol
--   related Google Services SDKs.
--   
--   The external interface of this library is stable with respect to the
--   downstream Gogol libraries, only, and as such is not suitable for use
--   in non-Gogol projects.
@package gogol-core
@version 0.5.0


module Network.Google.Data.JSON
type JSONValue = Value
newtype Textual a
Textual :: a -> Textual a
parseJSONObject :: FromJSON a => HashMap Text Value -> Parser a
parseJSONText :: FromHttpApiData a => String -> Value -> Parser a
toJSONText :: ToHttpApiData a => a -> Value

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><a>fail</a> yields a custom error message: it is the recommended
--   way of reporting a failure;</li>
--   <li><a>empty</a> (or <a>mzero</a>) is uninformative: use it when the
--   error is meant to be caught by some <tt>(<a>&lt;|&gt;</a>)</tt>;</li>
--   <li><a>typeMismatch</a> can be used to report a failure when the
--   encountered value is not of the expected JSON type; <a>unexpected</a>
--   is an appropriate alternative when more than one type may be expected,
--   or to keep the expected type implicit.</li>
--   </ul>
--   
--   <a>prependFailure</a> (or <a>modifyFailure</a>) add more information
--   to a parser's error messages.
--   
--   An example type and instance using <a>typeMismatch</a> and
--   <a>prependFailure</a>:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> (<a>Object</a> v) = Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   
--       -- We do not expect a non-<a>Object</a> value here.
--       -- We could use <a>empty</a> to fail, but <a>typeMismatch</a>
--       -- gives a much more informative error message.
--       <a>parseJSON</a> invalid    =
--           <a>prependFailure</a> "parsing Coord failed, "
--               (<a>typeMismatch</a> "Object" invalid)
--   </pre>
--   
--   For this common case of only being concerned with a single type of
--   JSON value, the functions <a>withObject</a>, <a>withScientific</a>,
--   etc. are provided. Their use is to be preferred when possible, since
--   they are more terse. Using <a>withObject</a>, we can rewrite the above
--   instance (assuming the same language extension and data type) as:
--   
--   <pre>
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>withObject</a> "Coord" $ \v -&gt; Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>FromJSON</a> Coord
--   </pre>
--   
--   The default implementation will be equivalent to <tt>parseJSON =
--   <a>genericParseJSON</a> <a>defaultOptions</a></tt>; if you need
--   different options, you can customize the generic decoding by defining:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>genericParseJSON</a> customOptions
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]

-- | A type that can be converted to JSON.
--   
--   Instances in general <i>must</i> specify <a>toJSON</a> and
--   <i>should</i> (but don't need to) specify <a>toEncoding</a>.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>ToJSON</a> Coord where
--     <a>toJSON</a> (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     <a>toEncoding</a> (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <a>&lt;&gt;</a> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance. If you
--   require nothing other than <a>defaultOptions</a>, it is sufficient to
--   write (and this is the only alternative where the default
--   <a>toJSON</a> implementation is sufficient):
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   If on the other hand you wish to customize the generic decoding, you
--   have to implement both methods:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toJSON</a>     = <a>genericToJSON</a> customOptions
--       <a>toEncoding</a> = <a>genericToEncoding</a> customOptions
--   </pre>
--   
--   Previous versions of this library only had the <a>toJSON</a> method.
--   Adding <a>toEncoding</a> had two reasons:
--   
--   <ol>
--   <li>toEncoding is more efficient for the common case that the output
--   of <a>toJSON</a> is directly serialized to a <tt>ByteString</tt>.
--   Further, expressing either method in terms of the other would be
--   non-optimal.</li>
--   <li>The choice of defaults allows a smooth transition for existing
--   users: Existing instances that do not define <a>toEncoding</a> still
--   compile and have the correct semantics. This is ensured by making the
--   default implementation of <a>toEncoding</a> use <a>toJSON</a>. This
--   produces correct results, but since it performs an intermediate
--   conversion to a <a>Value</a>, it will be less efficient than directly
--   emitting an <a>Encoding</a>. (this also means that specifying nothing
--   more than <tt>instance ToJSON Coord</tt> would be sufficient as a
--   generically decoding instance, but there probably exists no good
--   reason to not specify <a>toEncoding</a> in new instances.)</li>
--   </ol>
class ToJSON a

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: ToJSON a => a -> Value

-- | Encode a Haskell value as JSON.
--   
--   The default implementation of this method creates an intermediate
--   <a>Value</a> using <a>toJSON</a>. This provides source-level
--   compatibility for people upgrading from older versions of this
--   library, but obviously offers no performance advantage.
--   
--   To benefit from direct encoding, you <i>must</i> provide an
--   implementation for this method. The easiest way to do so is by having
--   your types implement <a>Generic</a> using the <tt>DeriveGeneric</tt>
--   extension, and then have GHC generate a method body as follows.
--   
--   <pre>
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding

-- | <tt><a>withObject</a> name f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <a>Object</a> and fails
--   otherwise.
--   
--   <h4>Error message example</h4>
--   
--   <pre>
--   withObject "MyType" f (String "oops")
--   -- Error: "parsing MyType failed, expected Object, but encountered String"
--   </pre>
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | The empty object.
emptyObject :: Value

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value
(.=) :: (KeyValue kv, ToJSON v) => Text -> v -> kv
infixr 8 .=

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use <a>.:?</a> instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present or if its value
--   is <a>Null</a>, or <tt>empty</tt> if the value cannot be converted to
--   the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use <a>.:</a> instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use
--   <a>.:</a> instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a
instance Web.Internal.HttpApiData.FromHttpApiData a => Web.Internal.HttpApiData.FromHttpApiData (Network.Google.Data.JSON.Textual a)
instance Web.Internal.HttpApiData.ToHttpApiData a => Web.Internal.HttpApiData.ToHttpApiData (Network.Google.Data.JSON.Textual a)
instance Data.Data.Data a => Data.Data.Data (Network.Google.Data.JSON.Textual a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Network.Google.Data.JSON.Textual a)
instance GHC.Num.Num a => GHC.Num.Num (Network.Google.Data.JSON.Textual a)
instance GHC.Show.Show a => GHC.Show.Show (Network.Google.Data.JSON.Textual a)
instance GHC.Read.Read a => GHC.Read.Read (Network.Google.Data.JSON.Textual a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Network.Google.Data.JSON.Textual a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Network.Google.Data.JSON.Textual a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Web.Internal.HttpApiData.FromHttpApiData a) => Data.Aeson.Types.FromJSON.FromJSON (Network.Google.Data.JSON.Textual a)
instance Web.Internal.HttpApiData.ToHttpApiData a => Data.Aeson.Types.ToJSON.ToJSON (Network.Google.Data.JSON.Textual a)


module Network.Google.Data.Bytes

-- | Binary data.
--   
--   This data is passed to/from the serialisation routines as-is, and any
--   particular encoding or decoding (say, base64) is left up to the
--   caller.
newtype Bytes
Bytes :: ByteString -> Bytes
[unBytes] :: Bytes -> ByteString
_Bytes :: Iso' Bytes ByteString
instance GHC.Generics.Generic Network.Google.Data.Bytes.Bytes
instance Data.Data.Data Network.Google.Data.Bytes.Bytes
instance GHC.Classes.Ord Network.Google.Data.Bytes.Bytes
instance GHC.Read.Read Network.Google.Data.Bytes.Bytes
instance GHC.Show.Show Network.Google.Data.Bytes.Bytes
instance GHC.Classes.Eq Network.Google.Data.Bytes.Bytes
instance Data.Hashable.Class.Hashable Network.Google.Data.Bytes.Bytes
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Data.Bytes.Bytes
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Data.Bytes.Bytes
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Data.Bytes.Bytes
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Data.Bytes.Bytes


module Network.Google.Data.Numeric
newtype Nat
Nat :: Natural -> Nat
[unNat] :: Nat -> Natural
instance Data.Data.Data Network.Google.Data.Numeric.Nat
instance GHC.Real.Integral Network.Google.Data.Numeric.Nat
instance GHC.Real.Real Network.Google.Data.Numeric.Nat
instance GHC.Num.Num Network.Google.Data.Numeric.Nat
instance GHC.Read.Read Network.Google.Data.Numeric.Nat
instance GHC.Show.Show Network.Google.Data.Numeric.Nat
instance GHC.Enum.Enum Network.Google.Data.Numeric.Nat
instance GHC.Classes.Ord Network.Google.Data.Numeric.Nat
instance GHC.Classes.Eq Network.Google.Data.Numeric.Nat
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Data.Numeric.Nat
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Data.Numeric.Nat
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Data.Numeric.Nat
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Data.Numeric.Nat


module Network.Google.Data.Time

-- | This SHOULD be a time in the format of hh:mm:ss. It is recommended
--   that you use the "date-time" format instead of "time" unless you need
--   to transfer only the time part.
data Time'

-- | This SHOULD be a date in the format of YYYY-MM-DD. It is recommended
--   that you use the "date-time" format instead of "date" unless you need
--   to transfer only the date part.
data Date'

-- | This SHOULD be a date in ISO 8601 format of YYYY-MM- DDThh:mm:ssZ in
--   UTC time. This is the recommended form of date/timestamp.
newtype DateTime'
DateTime' :: UTCTime -> DateTime'
[unDateTime] :: DateTime' -> UTCTime

-- | A duration in seconds with up to nine fractional digits, terminated by
--   <tt>s</tt>.
--   
--   <i>Example</i>: <tt>"3.5s"</tt>.
data GDuration
_Time :: Iso' Time' TimeOfDay
_Date :: Iso' Date' Day
_DateTime :: Iso' DateTime' UTCTime
_GDuration :: Iso' GDuration Scientific
instance Data.Data.Data Network.Google.Data.Time.GDuration
instance GHC.Generics.Generic Network.Google.Data.Time.GDuration
instance GHC.Read.Read Network.Google.Data.Time.GDuration
instance GHC.Show.Show Network.Google.Data.Time.GDuration
instance GHC.Classes.Ord Network.Google.Data.Time.GDuration
instance GHC.Classes.Eq Network.Google.Data.Time.GDuration
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Data.Time.DateTime'
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Data.Time.DateTime'
instance Data.Data.Data Network.Google.Data.Time.DateTime'
instance GHC.Generics.Generic Network.Google.Data.Time.DateTime'
instance GHC.Read.Read Network.Google.Data.Time.DateTime'
instance GHC.Show.Show Network.Google.Data.Time.DateTime'
instance GHC.Classes.Ord Network.Google.Data.Time.DateTime'
instance GHC.Classes.Eq Network.Google.Data.Time.DateTime'
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Data.Time.Date'
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Data.Time.Date'
instance Data.Data.Data Network.Google.Data.Time.Date'
instance GHC.Generics.Generic Network.Google.Data.Time.Date'
instance GHC.Read.Read Network.Google.Data.Time.Date'
instance GHC.Show.Show Network.Google.Data.Time.Date'
instance GHC.Classes.Ord Network.Google.Data.Time.Date'
instance GHC.Classes.Eq Network.Google.Data.Time.Date'
instance Data.Data.Data Network.Google.Data.Time.Time'
instance GHC.Generics.Generic Network.Google.Data.Time.Time'
instance GHC.Read.Read Network.Google.Data.Time.Time'
instance GHC.Show.Show Network.Google.Data.Time.Time'
instance GHC.Classes.Ord Network.Google.Data.Time.Time'
instance GHC.Classes.Eq Network.Google.Data.Time.Time'
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Data.Time.GDuration
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Data.Time.GDuration
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Data.Time.GDuration
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Data.Time.GDuration
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Data.Time.DateTime'
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Data.Time.DateTime'
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Data.Time.Date'
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Data.Time.Date'
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Data.Time.Time'
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Data.Time.Time'
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Data.Time.Time'
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Data.Time.Time'


module Network.Google.Types
data AltJSON
AltJSON :: AltJSON
data AltMedia
AltMedia :: AltMedia
data Multipart
Multipart :: Multipart

-- | An OAuth2 scope.
newtype OAuthScope
OAuthScope :: Text -> OAuthScope

-- | An OAuth2 access token.
newtype AccessToken
AccessToken :: Text -> AccessToken

-- | An OAuth2 refresh token.
newtype RefreshToken
RefreshToken :: Text -> RefreshToken

-- | A client identifier.
newtype ClientId
ClientId :: Text -> ClientId

-- | A service identifier.
newtype ServiceId
ServiceId :: Text -> ServiceId

-- | An opaque client secret.
newtype GSecret
GSecret :: Text -> GSecret
newtype MediaDownload a
MediaDownload :: a -> MediaDownload a
data MediaUpload a
MediaUpload :: a -> GBody -> MediaUpload a
_Coerce :: (Coercible a b, Coercible b a) => Iso' a b

-- | Invalid Iso, exists for ease of composition with the current 'Lens .
--   Iso' chaining to hide internal types from the user.
_Default :: Monoid a => Iso' (Maybe a) a
type Stream = ConduitM () ByteString (ResourceT IO) ()
data Error
TransportError :: HttpException -> Error
SerializeError :: SerializeError -> Error
ServiceError :: ServiceError -> Error
data SerializeError
SerializeError' :: !ServiceId -> [Header] -> !Status -> !String -> !Maybe ByteString -> SerializeError
[_serializeId] :: SerializeError -> !ServiceId
[_serializeHeaders] :: SerializeError -> [Header]
[_serializeStatus] :: SerializeError -> !Status
[_serializeMessage] :: SerializeError -> !String
[_serializeBody] :: SerializeError -> !Maybe ByteString
data ServiceError
ServiceError' :: !ServiceId -> !Status -> ![Header] -> !Maybe ByteString -> ServiceError
[_serviceId] :: ServiceError -> !ServiceId
[_serviceStatus] :: ServiceError -> !Status
[_serviceHeaders] :: ServiceError -> ![Header]
[_serviceBody] :: ServiceError -> !Maybe ByteString
class AsError a

-- | A general Amazonka error.
_Error :: AsError a => Prism' a Error

-- | An error occured while communicating over HTTP with a remote service.
_TransportError :: AsError a => Prism' a HttpException

-- | A serialisation error occured when attempting to deserialise a
--   response.
_SerializeError :: AsError a => Prism' a SerializeError

-- | A service specific error returned by the remote service.
_ServiceError :: AsError a => Prism' a ServiceError
data ServiceConfig
ServiceConfig :: !ServiceId -> !ByteString -> !Builder -> !Int -> !Bool -> !Maybe Seconds -> ServiceConfig
[_svcId] :: ServiceConfig -> !ServiceId
[_svcHost] :: ServiceConfig -> !ByteString
[_svcPath] :: ServiceConfig -> !Builder
[_svcPort] :: ServiceConfig -> !Int
[_svcSecure] :: ServiceConfig -> !Bool
[_svcTimeout] :: ServiceConfig -> !Maybe Seconds
defaultService :: ServiceId -> ByteString -> ServiceConfig

-- | The remote host name, used for both the IP address to connect to and
--   the host request header.
serviceHost :: Lens' ServiceConfig ByteString

-- | The remote port to connect to.
--   
--   Defaults to <tt>443</tt>.
servicePort :: Lens' ServiceConfig Int

-- | A path prefix that is prepended to any sent HTTP request.
--   
--   Defaults to <tt>mempty</tt>.
servicePath :: Lens' ServiceConfig Builder

-- | Whether to use HTTPS/SSL.
--   
--   Defaults to <tt>True</tt>.
serviceSecure :: Lens' ServiceConfig Bool

-- | Number of seconds to wait for a response.
serviceTimeout :: Lens' ServiceConfig (Maybe Seconds)

-- | A single part of a (potentially multipart) request body.
--   
--   <i>Note:</i> The <a>IsString</a> instance defaults to a
--   <tt>text/plain</tt> MIME type.
data GBody
GBody :: !MediaType -> !RequestBody -> GBody

-- | A lens into the <a>MediaType</a> of a request <tt>Body</tt>.
bodyContentType :: Lens' GBody MediaType

-- | An intermediary request builder.
data Request
Request :: !Builder -> !DList (ByteString, Maybe ByteString) -> !DList (HeaderName, ByteString) -> ![GBody] -> Request
[_rqPath] :: Request -> !Builder
[_rqQuery] :: Request -> !DList (ByteString, Maybe ByteString)
[_rqHeaders] :: Request -> !DList (HeaderName, ByteString)
[_rqBody] :: Request -> ![GBody]
appendPath :: Request -> Builder -> Request
appendPaths :: ToHttpApiData a => Request -> [a] -> Request
appendQuery :: Request -> ByteString -> Maybe Text -> Request
appendHeader :: Request -> HeaderName -> Maybe Text -> Request
setBody :: Request -> [GBody] -> Request

-- | A materialised 'http-client' request and associated response parser.
data GClient a
GClient :: !Maybe MediaType -> !Method -> !Status -> Bool -> !ServiceConfig -> !Request -> !Stream -> ResourceT IO (Either (String, ByteString) a) -> GClient a
[_cliAccept] :: GClient a -> !Maybe MediaType
[_cliMethod] :: GClient a -> !Method
[_cliCheck] :: GClient a -> !Status -> Bool
[_cliService] :: GClient a -> !ServiceConfig
[_cliRequest] :: GClient a -> !Request
[_cliResponse] :: GClient a -> !Stream -> ResourceT IO (Either (String, ByteString) a)
clientService :: Lens' (GClient a) ServiceConfig
mime :: FromStream c a => Proxy c -> Method -> [Int] -> Request -> ServiceConfig -> GClient a
discard :: Method -> [Int] -> Request -> ServiceConfig -> GClient ()
gClient :: (Stream -> ResourceT IO (Either (String, ByteString) a)) -> Maybe MediaType -> Method -> [Int] -> Request -> ServiceConfig -> GClient a
class Accept c => ToBody c a
toBody :: ToBody c a => Proxy c -> a -> GBody
class Accept c => FromStream c a
fromStream :: FromStream c a => Proxy c -> Stream -> ResourceT IO (Either (String, ByteString) a)
class GoogleRequest a where {
    type family Rs a :: *;
    type family Scopes a :: [Symbol];
}
requestClient :: GoogleRequest a => a -> GClient (Rs a)
class GoogleClient fn where {
    type family Fn fn :: *;
}
buildClient :: GoogleClient fn => Proxy fn -> Request -> Fn fn

-- | Multiple path captures, with <tt>[xs]</tt> forming
--   <tt><i><a>x1</a></i><a>x2</a><i><a>x2</a></i>...</tt>.
data Captures (s :: Symbol) a

-- | Form a Google style sub-resource, such as
--   <tt>/<a>capture</a>:<a>mode</a></tt>.
data CaptureMode (s :: Symbol) (m :: Symbol) a
data MultipartRelated (cs :: [*]) m
sinkLBS :: Stream -> ResourceT IO ByteString
buildText :: ToHttpApiData a => a -> Builder
buildSymbol :: forall n proxy. KnownSymbol n => proxy n -> Builder
byteSymbol :: forall n proxy. KnownSymbol n => proxy n -> ByteString

-- | An integral value representing seconds.
newtype Seconds
Seconds :: Int -> Seconds
seconds :: Seconds -> Int
microseconds :: Seconds -> Int
newtype GFieldMask
GFieldMask :: Text -> GFieldMask
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Types.GFieldMask
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Types.GFieldMask
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.GFieldMask
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Types.GFieldMask
instance Data.Data.Data Network.Google.Types.GFieldMask
instance GHC.Generics.Generic Network.Google.Types.GFieldMask
instance Data.String.IsString Network.Google.Types.GFieldMask
instance GHC.Read.Read Network.Google.Types.GFieldMask
instance GHC.Show.Show Network.Google.Types.GFieldMask
instance GHC.Classes.Ord Network.Google.Types.GFieldMask
instance GHC.Classes.Eq Network.Google.Types.GFieldMask
instance GHC.Generics.Generic Network.Google.Types.Seconds
instance Data.Data.Data Network.Google.Types.Seconds
instance GHC.Real.Real Network.Google.Types.Seconds
instance GHC.Real.Integral Network.Google.Types.Seconds
instance GHC.Enum.Bounded Network.Google.Types.Seconds
instance GHC.Num.Num Network.Google.Types.Seconds
instance GHC.Enum.Enum Network.Google.Types.Seconds
instance GHC.Show.Show Network.Google.Types.Seconds
instance GHC.Read.Read Network.Google.Types.Seconds
instance GHC.Classes.Ord Network.Google.Types.Seconds
instance GHC.Classes.Eq Network.Google.Types.Seconds
instance GHC.Show.Show Network.Google.Types.Error
instance GHC.Show.Show Network.Google.Types.ServiceError
instance GHC.Classes.Eq Network.Google.Types.ServiceError
instance GHC.Show.Show Network.Google.Types.SerializeError
instance GHC.Classes.Eq Network.Google.Types.SerializeError
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Types.GSecret
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Types.GSecret
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.GSecret
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Types.GSecret
instance GHC.Generics.Generic Network.Google.Types.GSecret
instance Data.String.IsString Network.Google.Types.GSecret
instance GHC.Read.Read Network.Google.Types.GSecret
instance GHC.Classes.Ord Network.Google.Types.GSecret
instance GHC.Classes.Eq Network.Google.Types.GSecret
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Types.ServiceId
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Types.ServiceId
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.ServiceId
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Types.ServiceId
instance GHC.Generics.Generic Network.Google.Types.ServiceId
instance Data.String.IsString Network.Google.Types.ServiceId
instance GHC.Read.Read Network.Google.Types.ServiceId
instance GHC.Show.Show Network.Google.Types.ServiceId
instance GHC.Classes.Ord Network.Google.Types.ServiceId
instance GHC.Classes.Eq Network.Google.Types.ServiceId
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Types.ClientId
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Types.ClientId
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.ClientId
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Types.ClientId
instance GHC.Generics.Generic Network.Google.Types.ClientId
instance Data.String.IsString Network.Google.Types.ClientId
instance GHC.Read.Read Network.Google.Types.ClientId
instance GHC.Show.Show Network.Google.Types.ClientId
instance GHC.Classes.Ord Network.Google.Types.ClientId
instance GHC.Classes.Eq Network.Google.Types.ClientId
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Types.RefreshToken
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Types.RefreshToken
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.RefreshToken
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Types.RefreshToken
instance GHC.Generics.Generic Network.Google.Types.RefreshToken
instance Data.String.IsString Network.Google.Types.RefreshToken
instance GHC.Read.Read Network.Google.Types.RefreshToken
instance GHC.Show.Show Network.Google.Types.RefreshToken
instance GHC.Classes.Ord Network.Google.Types.RefreshToken
instance GHC.Classes.Eq Network.Google.Types.RefreshToken
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Types.AccessToken
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Types.AccessToken
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.AccessToken
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Types.AccessToken
instance GHC.Generics.Generic Network.Google.Types.AccessToken
instance Data.String.IsString Network.Google.Types.AccessToken
instance GHC.Read.Read Network.Google.Types.AccessToken
instance GHC.Show.Show Network.Google.Types.AccessToken
instance GHC.Classes.Ord Network.Google.Types.AccessToken
instance GHC.Classes.Eq Network.Google.Types.AccessToken
instance Data.Aeson.Types.ToJSON.ToJSON Network.Google.Types.OAuthScope
instance Data.Aeson.Types.FromJSON.FromJSON Network.Google.Types.OAuthScope
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.OAuthScope
instance Web.Internal.HttpApiData.FromHttpApiData Network.Google.Types.OAuthScope
instance GHC.Generics.Generic Network.Google.Types.OAuthScope
instance Data.String.IsString Network.Google.Types.OAuthScope
instance GHC.Read.Read Network.Google.Types.OAuthScope
instance GHC.Show.Show Network.Google.Types.OAuthScope
instance GHC.Classes.Ord Network.Google.Types.OAuthScope
instance GHC.Classes.Eq Network.Google.Types.OAuthScope
instance GHC.Generics.Generic Network.Google.Types.Multipart
instance GHC.Read.Read Network.Google.Types.Multipart
instance GHC.Show.Show Network.Google.Types.Multipart
instance GHC.Classes.Ord Network.Google.Types.Multipart
instance GHC.Classes.Eq Network.Google.Types.Multipart
instance GHC.Generics.Generic Network.Google.Types.AltMedia
instance GHC.Read.Read Network.Google.Types.AltMedia
instance GHC.Show.Show Network.Google.Types.AltMedia
instance GHC.Classes.Ord Network.Google.Types.AltMedia
instance GHC.Classes.Eq Network.Google.Types.AltMedia
instance GHC.Generics.Generic Network.Google.Types.AltJSON
instance GHC.Read.Read Network.Google.Types.AltJSON
instance GHC.Show.Show Network.Google.Types.AltJSON
instance GHC.Classes.Ord Network.Google.Types.AltJSON
instance GHC.Classes.Eq Network.Google.Types.AltJSON
instance Network.Google.Types.FromStream c a => Network.Google.Types.GoogleClient (Servant.API.Verbs.Get (c : cs) a)
instance Network.Google.Types.GoogleClient (Servant.API.Verbs.Get (c : cs) ())
instance (Network.Google.Types.FromStream c a, cs' GHC.Types.~ (c : cs)) => Network.Google.Types.GoogleClient (Servant.API.Verbs.Post cs' a)
instance Network.Google.Types.GoogleClient (Servant.API.Verbs.Post cs ())
instance Network.Google.Types.FromStream c a => Network.Google.Types.GoogleClient (Servant.API.Verbs.Put (c : cs) a)
instance Network.Google.Types.GoogleClient (Servant.API.Verbs.Put (c : cs) ())
instance Network.Google.Types.FromStream c a => Network.Google.Types.GoogleClient (Servant.API.Verbs.Patch (c : cs) a)
instance Network.Google.Types.GoogleClient (Servant.API.Verbs.Patch (c : cs) ())
instance Network.Google.Types.FromStream c a => Network.Google.Types.GoogleClient (Servant.API.Verbs.Delete (c : cs) a)
instance Network.Google.Types.GoogleClient (Servant.API.Verbs.Delete (c : cs) ())
instance (Network.Google.Types.ToBody c m, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Network.Google.Types.MultipartRelated (c : cs) m Servant.API.Sub.:> fn)
instance (GHC.TypeLits.KnownSymbol s, GHC.TypeLits.KnownSymbol m, Web.Internal.HttpApiData.ToHttpApiData a, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Network.Google.Types.CaptureMode s m a Servant.API.Sub.:> fn)
instance (GHC.TypeLits.KnownSymbol s, Web.Internal.HttpApiData.ToHttpApiData a, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Network.Google.Types.Captures s a Servant.API.Sub.:> fn)
instance Network.Google.Types.GoogleClient fn => Network.Google.Types.GoogleClient (Network.Google.Types.AltMedia Servant.API.Sub.:> fn)
instance (GHC.TypeLits.KnownSymbol s, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (s Servant.API.Sub.:> fn)
instance (Network.Google.Types.GoogleClient a, Network.Google.Types.GoogleClient b) => Network.Google.Types.GoogleClient (a Servant.API.Alternative.:<|> b)
instance (GHC.TypeLits.KnownSymbol s, Web.Internal.HttpApiData.ToHttpApiData a, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Servant.API.Capture.Capture s a Servant.API.Sub.:> fn)
instance (GHC.TypeLits.KnownSymbol s, Web.Internal.HttpApiData.ToHttpApiData a, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Servant.API.QueryParam.QueryParam s a Servant.API.Sub.:> fn)
instance (GHC.TypeLits.KnownSymbol s, Web.Internal.HttpApiData.ToHttpApiData a, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Servant.API.QueryParam.QueryParams s a Servant.API.Sub.:> fn)
instance (GHC.TypeLits.KnownSymbol s, Web.Internal.HttpApiData.ToHttpApiData a, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Servant.API.Header.Header s a Servant.API.Sub.:> fn)
instance (Network.Google.Types.ToBody c a, Network.Google.Types.GoogleClient fn) => Network.Google.Types.GoogleClient (Servant.API.ReqBody.ReqBody (c : cs) a Servant.API.Sub.:> fn)
instance Network.Google.Types.FromStream Servant.API.ContentTypes.OctetStream Network.Google.Types.Stream
instance Data.Aeson.Types.FromJSON.FromJSON a => Network.Google.Types.FromStream Servant.API.ContentTypes.JSON a
instance Network.Google.Types.ToBody Servant.API.ContentTypes.OctetStream Data.ByteString.Internal.ByteString
instance Network.Google.Types.ToBody Servant.API.ContentTypes.OctetStream Data.ByteString.Lazy.Internal.ByteString
instance Network.Google.Types.ToBody Servant.API.ContentTypes.PlainText Data.ByteString.Internal.ByteString
instance Network.Google.Types.ToBody Servant.API.ContentTypes.PlainText Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Types.ToJSON.ToJSON a => Network.Google.Types.ToBody Servant.API.ContentTypes.JSON a
instance GHC.Base.Monoid Network.Google.Types.Request
instance GHC.Base.Semigroup Network.Google.Types.Request
instance Data.String.IsString Network.Google.Types.GBody
instance Network.Google.Types.AsError GHC.Exception.Type.SomeException
instance Network.Google.Types.AsError Network.Google.Types.Error
instance GHC.Exception.Type.Exception Network.Google.Types.Error
instance GHC.Show.Show Network.Google.Types.GSecret
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.Multipart
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.AltMedia
instance Web.Internal.HttpApiData.ToHttpApiData Network.Google.Types.AltJSON


module Network.Google.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b
infixr 0 `seq`

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(min(m,n))</i>. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | <i>O(n)</i>. <a>map</a> <tt>f xs</tt> is the list obtained by applying
--   <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 7 *
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <=
infix 4 <

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <tt>O(n)</tt>
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a>  <a>id</a>
--   <a>to</a> . <a>from</a>  <a>id</a>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | 32-bit signed integer type
data Int32

-- | 64-bit signed integer type
data Int64

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | 8-bit unsigned integer type
data Word8

-- | 32-bit unsigned integer type
data Word32

-- | 64-bit unsigned integer type
data Word64

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | An arbitrary-precision number represented using <a>scientific
--   notation</a>.
--   
--   This type describes the set of all <tt><a>Real</a>s</tt> which have a
--   finite decimal expansion.
--   
--   A scientific number with <a>coefficient</a> <tt>c</tt> and
--   <a>base10Exponent</a> <tt>e</tt> corresponds to the <a>Fractional</a>
--   number: <tt><a>fromInteger</a> c * 10 <a>^^</a> e</tt>
data Scientific

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | The class of types that can be converted to a hash value.
--   
--   Minimal implementation: <a>hashWithSalt</a>.
class Hashable a

-- | Return a hash value for the argument, using the given salt.
--   
--   The general contract of <a>hashWithSalt</a> is:
--   
--   <ul>
--   <li>If two values are equal according to the <a>==</a> method, then
--   applying the <a>hashWithSalt</a> method on each of the two values
--   <i>must</i> produce the same integer result if the same salt is used
--   in each case.</li>
--   <li>It is <i>not</i> required that if two values are unequal according
--   to the <a>==</a> method, then applying the <a>hashWithSalt</a> method
--   on each of the two values must produce distinct integer results.
--   However, the programmer should be aware that producing distinct
--   integer results for unequal values may improve the performance of
--   hashing-based data structures.</li>
--   <li>This method can be used to compute different hash values for the
--   same input by providing a different salt in each application of the
--   method. This implies that any instance that defines
--   <a>hashWithSalt</a> <i>must</i> make use of the salt in its
--   implementation.</li>
--   </ul>
hashWithSalt :: Hashable a => Int -> a -> Int
infixl 0 `hashWithSalt`

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime

-- | A map from keys to values. A map cannot contain duplicate keys; each
--   key can map to at most one value.
data HashMap k v

-- | A type that can be converted to JSON.
--   
--   Instances in general <i>must</i> specify <a>toJSON</a> and
--   <i>should</i> (but don't need to) specify <a>toEncoding</a>.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>ToJSON</a> Coord where
--     <a>toJSON</a> (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     <a>toEncoding</a> (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <a>&lt;&gt;</a> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance. If you
--   require nothing other than <a>defaultOptions</a>, it is sufficient to
--   write (and this is the only alternative where the default
--   <a>toJSON</a> implementation is sufficient):
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   If on the other hand you wish to customize the generic decoding, you
--   have to implement both methods:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toJSON</a>     = <a>genericToJSON</a> customOptions
--       <a>toEncoding</a> = <a>genericToEncoding</a> customOptions
--   </pre>
--   
--   Previous versions of this library only had the <a>toJSON</a> method.
--   Adding <a>toEncoding</a> had two reasons:
--   
--   <ol>
--   <li>toEncoding is more efficient for the common case that the output
--   of <a>toJSON</a> is directly serialized to a <tt>ByteString</tt>.
--   Further, expressing either method in terms of the other would be
--   non-optimal.</li>
--   <li>The choice of defaults allows a smooth transition for existing
--   users: Existing instances that do not define <a>toEncoding</a> still
--   compile and have the correct semantics. This is ensured by making the
--   default implementation of <a>toEncoding</a> use <a>toJSON</a>. This
--   produces correct results, but since it performs an intermediate
--   conversion to a <a>Value</a>, it will be less efficient than directly
--   emitting an <a>Encoding</a>. (this also means that specifying nothing
--   more than <tt>instance ToJSON Coord</tt> would be sufficient as a
--   generically decoding instance, but there probably exists no good
--   reason to not specify <a>toEncoding</a> in new instances.)</li>
--   </ol>
class ToJSON a

-- | Convert a Haskell value to a JSON-friendly intermediate type.
toJSON :: ToJSON a => a -> Value

-- | Encode a Haskell value as JSON.
--   
--   The default implementation of this method creates an intermediate
--   <a>Value</a> using <a>toJSON</a>. This provides source-level
--   compatibility for people upgrading from older versions of this
--   library, but obviously offers no performance advantage.
--   
--   To benefit from direct encoding, you <i>must</i> provide an
--   implementation for this method. The easiest way to do so is by having
--   your types implement <a>Generic</a> using the <tt>DeriveGeneric</tt>
--   extension, and then have GHC generate a method body as follows.
--   
--   <pre>
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding
(.=) :: (KeyValue kv, ToJSON v) => Text -> v -> kv
infixr 8 .=

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use
--   <a>.:</a> instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present or if its value
--   is <a>Null</a>, or <tt>empty</tt> if the value cannot be converted to
--   the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use <a>.:</a> instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use <a>.:?</a> instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | <tt><a>withObject</a> name f value</tt> applies <tt>f</tt> to the
--   <a>Object</a> when <tt>value</tt> is an <a>Object</a> and fails
--   otherwise.
--   
--   <h4>Error message example</h4>
--   
--   <pre>
--   withObject "MyType" f (String "oops")
--   -- Error: "parsing MyType failed, expected Object, but encountered String"
--   </pre>
withObject :: String -> (Object -> Parser a) -> Value -> Parser a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><a>fail</a> yields a custom error message: it is the recommended
--   way of reporting a failure;</li>
--   <li><a>empty</a> (or <a>mzero</a>) is uninformative: use it when the
--   error is meant to be caught by some <tt>(<a>&lt;|&gt;</a>)</tt>;</li>
--   <li><a>typeMismatch</a> can be used to report a failure when the
--   encountered value is not of the expected JSON type; <a>unexpected</a>
--   is an appropriate alternative when more than one type may be expected,
--   or to keep the expected type implicit.</li>
--   </ul>
--   
--   <a>prependFailure</a> (or <a>modifyFailure</a>) add more information
--   to a parser's error messages.
--   
--   An example type and instance using <a>typeMismatch</a> and
--   <a>prependFailure</a>:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> (<a>Object</a> v) = Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   
--       -- We do not expect a non-<a>Object</a> value here.
--       -- We could use <a>empty</a> to fail, but <a>typeMismatch</a>
--       -- gives a much more informative error message.
--       <a>parseJSON</a> invalid    =
--           <a>prependFailure</a> "parsing Coord failed, "
--               (<a>typeMismatch</a> "Object" invalid)
--   </pre>
--   
--   For this common case of only being concerned with a single type of
--   JSON value, the functions <a>withObject</a>, <a>withScientific</a>,
--   etc. are provided. Their use is to be preferred when possible, since
--   they are more terse. Using <a>withObject</a>, we can rewrite the above
--   instance (assuming the same language extension and data type) as:
--   
--   <pre>
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>withObject</a> "Coord" $ \v -&gt; Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>FromJSON</a> Coord
--   </pre>
--   
--   The default implementation will be equivalent to <tt>parseJSON =
--   <a>genericParseJSON</a> <a>defaultOptions</a></tt>; if you need
--   different options, you can customize the generic decoding by defining:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>genericParseJSON</a> customOptions
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | The empty object.
emptyObject :: Value

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <tt>fail</tt> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | <a>asProxyTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Proxy :: Proxy Word8)
--   asProxyTypeOf 123 (Proxy :: Proxy Word8) :: Word8
--   </pre>
--   
--   Note the lower-case <tt>proxy</tt> in the definition. This allows any
--   type constructor with just one argument to be passed to the function,
--   for example we could also write
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Just (undefined :: Word8))
--   asProxyTypeOf 123 (Just (undefined :: Word8)) :: Word8
--   </pre>
asProxyTypeOf :: a -> proxy a -> a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | A concrete, promotable proxy type, for use at the kind level. There
--   are no instances for this because it is intended at the kind level
--   only
data KProxy t
KProxy :: KProxy t

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <i>O(min(m,n))</i>. <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | <i>O(n)</i>. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | <i>O(n)</i>. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <i>O(n)</i>. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <i>O(n)</i>. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <i>O(n)</i>. Return all the elements of a list except the last one.
--   The list must be non-empty.
init :: [a] -> [a]

-- | <i>O(n)</i>. Extract the last element of a list, which must be finite
--   and non-empty.
last :: [a] -> a

-- | <i>O(1)</i>. Extract the elements after the head of a list, which must
--   be non-empty.
tail :: [a] -> [a]

-- | <i>O(1)</i>. Extract the first element of a list, which must be
--   non-empty.
head :: [a] -> a

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Type-level <a>If</a>. <tt>If True a b</tt> ==&gt; <tt>a</tt>; <tt>If
--   False a b</tt> ==&gt; <tt>b</tt>
type family If (cond :: Bool) (tru :: k) (fls :: k) :: k

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | Convert value to HTTP API data.
--   
--   <b>WARNING</b>: Do not derive this using <tt>DeriveAnyClass</tt> as
--   the generated instance will loop indefinitely.
class ToHttpApiData a

-- | Convert to URL path piece.
toUrlPiece :: ToHttpApiData a => a -> Text

-- | Convert to a URL path piece, making sure to encode any special chars.
--   The default definition uses <a>encodePathSegmentsRelative</a>, but
--   this may be overriden with a more efficient version.
toEncodedUrlPiece :: ToHttpApiData a => a -> Builder

-- | Convert to HTTP header value.
toHeader :: ToHttpApiData a => a -> ByteString

-- | Convert to query param value.
toQueryParam :: ToHttpApiData a => a -> Text

-- | Parse value from HTTP API data.
--   
--   <b>WARNING</b>: Do not derive this using <tt>DeriveAnyClass</tt> as
--   the generated instance will loop indefinitely.
class FromHttpApiData a

-- | Parse URL path piece.
parseUrlPiece :: FromHttpApiData a => Text -> Either Text a

-- | Parse HTTP header value.
parseHeader :: FromHttpApiData a => ByteString -> Either Text a

-- | Parse query param value.
parseQueryParam :: FromHttpApiData a => Text -> Either Text a

-- | Represents a general universal resource identifier using its component
--   parts.
--   
--   For example, for the URI
--   
--   <pre>
--   foo://anonymous@www.haskell.org:42/ghc?query#frag
--   </pre>
--   
--   the components are:
data URI
URI :: String -> Maybe URIAuth -> String -> String -> String -> URI

-- | <pre>
--   foo:
--   </pre>
[uriScheme] :: URI -> String

-- | <pre>
--   //anonymous@www.haskell.org:42
--   </pre>
[uriAuthority] :: URI -> Maybe URIAuth

-- | <pre>
--   /ghc
--   </pre>
[uriPath] :: URI -> String

-- | <pre>
--   ?query
--   </pre>
[uriQuery] :: URI -> String

-- | <pre>
--   #frag
--   </pre>
[uriFragment] :: URI -> String

-- | When using one of the <a>RequestBodyStream</a> /
--   <a>RequestBodyStreamChunked</a> constructors, you must ensure that the
--   <a>GivesPopper</a> can be called multiple times. Usually this is not a
--   problem.
--   
--   The <a>RequestBodyStreamChunked</a> will send a chunked request body.
--   Note that not all servers support this. Only use
--   <a>RequestBodyStreamChunked</a> if you know the server you're sending
--   to supports chunked request bodies.
--   
--   Since 0.1.0
data RequestBody

-- | HTTP Version.
--   
--   Note that the Show instance is intended merely for debugging.
data HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
[httpMajor] :: HttpVersion -> !Int
[httpMinor] :: HttpVersion -> !Int

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data StdMethod
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod
PATCH :: StdMethod

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: forall (f :: Type -> Type) (g :: Type -> Type) s t a b. (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the target
--   of the value of <a>Just</a> in a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over _Just (+1) (Just 2)
--   Just 3
--   </pre>
--   
--   Unlike <a>traverse</a> this is a <a>Prism</a>, and so you can use it
--   to inject as well:
--   
--   <pre>
--   &gt;&gt;&gt; _Just # 5
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Just
--   Just 5
--   </pre>
--   
--   Interestingly,
--   
--   <pre>
--   m <tt>^?</tt> <a>_Just</a>  m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just x ^? _Just
--   Just x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Just
--   Nothing
--   </pre>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x  f x
--   l # x  x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t
infixr 8 #

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | More general version of <a>allFieldLinks</a>.
allFieldLinks' :: (HasLink (ToServantApi routes), GenericServant routes (AsLink a), ToServant routes (AsLink a) ~ MkLink (ToServantApi routes) a) => (Link -> a) -> routes (AsLink a)

-- | Get all links as a record.
allFieldLinks :: (HasLink (ToServantApi routes), GenericServant routes (AsLink Link), ToServant routes (AsLink Link) ~ MkLink (ToServantApi routes) Link) => routes (AsLink Link)

-- | More general version of <a>fieldLink</a>
fieldLink' :: forall routes endpoint a. (IsElem endpoint (ToServantApi routes), HasLink endpoint, GenericServant routes AsApi) => (Link -> a) -> (routes AsApi -> endpoint) -> MkLink endpoint a

-- | Given an API record field, create a link for that route. Only the
--   field's type is used.
--   
--   <pre>
--   data Record route = Record
--       { _get :: route :- Capture "id" Int :&gt; Get '[JSON] String
--       , _put :: route :- ReqBody '[JSON] Int :&gt; Put '[JSON] Bool
--       }
--     deriving (<a>Generic</a>)
--   
--   getLink :: Int -&gt; Link
--   getLink = <a>fieldLink</a> _get
--   </pre>
fieldLink :: (IsElem endpoint (ToServantApi routes), HasLink endpoint, GenericServant routes AsApi) => (routes AsApi -> endpoint) -> MkLink endpoint Link

-- | More general <a>allLinks</a>. See <a>safeLink</a>`.
allLinks' :: forall k (api :: k) a. HasLink api => (Link -> a) -> Proxy api -> MkLink api a

-- | Create all links in an API.
--   
--   Note that the <tt>api</tt> type must be restricted to the endpoints
--   that have valid links to them.
--   
--   <pre>
--   &gt;&gt;&gt; type API = "foo" :&gt; Capture "name" Text :&gt; Get '[JSON] Text :&lt;|&gt; "bar" :&gt; Capture "name" Int :&gt; Get '[JSON] Double
--   
--   &gt;&gt;&gt; let fooLink :&lt;|&gt; barLink = allLinks (Proxy :: Proxy API)
--   
--   &gt;&gt;&gt; :t fooLink
--   fooLink :: Text -&gt; Link
--   
--   &gt;&gt;&gt; :t barLink
--   barLink :: Int -&gt; Link
--   </pre>
--   
--   Note: nested APIs don't work well with this approach
--   
--   <pre>
--   &gt;&gt;&gt; :kind! MkLink (Capture "nest" Char :&gt; (Capture "x" Int :&gt; Get '[JSON] Int :&lt;|&gt; Capture "y" Double :&gt; Get '[JSON] Double)) Link
--   MkLink (Capture "nest" Char :&gt; (Capture "x" Int :&gt; Get '[JSON] Int :&lt;|&gt; Capture "y" Double :&gt; Get '[JSON] Double)) Link :: *
--   = Char -&gt; (Int -&gt; Link) :&lt;|&gt; (Double -&gt; Link)
--   </pre>
allLinks :: forall k (api :: k). HasLink api => Proxy api -> MkLink api Link

-- | More general <a>safeLink</a>.
safeLink' :: (IsElem endpoint api, HasLink endpoint) => (Link -> a) -> Proxy api -> Proxy endpoint -> MkLink endpoint a

-- | Create a valid (by construction) relative URI with query params.
--   
--   This function will only typecheck if <tt>endpoint</tt> is part of the
--   API <tt>api</tt>
safeLink :: (IsElem endpoint api, HasLink endpoint) => Proxy api -> Proxy endpoint -> MkLink endpoint Link

-- | Configurable <a>linkURI</a>.
--   
--   <pre>
--   &gt;&gt;&gt; type API = "sum" :&gt; QueryParams "x" Int :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI' LinkArrayElementBracket $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API) [1, 2, 3]
--   sum?x[]=1&amp;x[]=2&amp;x[]=3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linkURI' LinkArrayElementPlain $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API) [1, 2, 3]
--   sum?x=1&amp;x=2&amp;x=3
--   </pre>
linkURI' :: LinkArrayElementStyle -> Link -> URI

-- | Transform <a>Link</a> into <a>URI</a>.
--   
--   <pre>
--   &gt;&gt;&gt; type API = "something" :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API)
--   something
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type API = "sum" :&gt; QueryParams "x" Int :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API) [1, 2, 3]
--   sum?x[]=1&amp;x[]=2&amp;x[]=3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type API = "foo/bar" :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API)
--   foo%2Fbar
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type SomeRoute = "abc" :&gt; Capture "email" String :&gt; Put '[JSON] ()
--   
--   &gt;&gt;&gt; let someRoute = Proxy :: Proxy SomeRoute
--   
--   &gt;&gt;&gt; safeLink someRoute someRoute "test@example.com"
--   Link {_segments = ["abc","test%40example.com"], _queryParams = []}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linkURI $ safeLink someRoute someRoute "test@example.com"
--   abc/test%40example.com
--   </pre>
linkURI :: Link -> URI
linkQueryParams :: Link -> [Param]
linkSegments :: Link -> [String]

-- | Query parameter.
data Param
SingleParam :: String -> Text -> Param
ArrayElemParam :: String -> Text -> Param
FlagParam :: String -> Param

-- | How to encode array query elements.
data LinkArrayElementStyle

-- | <pre>
--   foo[]=1&amp;foo[]=2
--   </pre>
LinkArrayElementBracket :: LinkArrayElementStyle

-- | <pre>
--   foo=1&amp;foo=2
--   </pre>
LinkArrayElementPlain :: LinkArrayElementStyle

-- | A type that specifies that an API record contains a set of links.
data AsLink a
type family MkLink (endpoint :: k) a

-- | Construct a toLink for an endpoint.
class HasLink (endpoint :: k) where {
    type family MkLink (endpoint :: k) a;
}
toLink :: HasLink endpoint => (Link -> a) -> Proxy endpoint -> Link -> MkLink endpoint a
type StreamGet = Stream 'GET 200
type StreamPost = Stream 'POST 200

-- | A stream request body.
type StreamBody = StreamBody' '[] :: [Type]
data StreamBody' (mods :: [Type]) framing contentType a

-- | Stream endpoints may be implemented as producing a <tt><a>SourceIO</a>
--   chunk</tt>.
--   
--   Clients reading from streaming endpoints can be implemented as
--   consuming a <tt><a>SourceIO</a> chunk</tt>.
type SourceIO = SourceT IO

-- | <a>ToSourceIO</a> is intended to be implemented for types such as
--   Conduit, Pipe, etc. By implementing this class, all such streaming
--   abstractions can be used directly as endpoints.
class ToSourceIO chunk a | a -> chunk
toSourceIO :: ToSourceIO chunk a => a -> SourceIO chunk

-- | <a>FromSourceIO</a> is intended to be implemented for types such as
--   Conduit, Pipe, etc. By implementing this class, all such streaming
--   abstractions can be used directly on the client side for talking to
--   streaming endpoints.
class FromSourceIO chunk a | a -> chunk
fromSourceIO :: FromSourceIO chunk a => SourceIO chunk -> a

-- | The <a>FramingRender</a> class provides the logic for emitting a
--   framing strategy. The strategy transforms a <tt><a>SourceT</a> m
--   a</tt> into <tt><a>SourceT</a> m <a>ByteString</a></tt>, therefore it
--   can prepend, append and intercalate <i>framing</i> structure around
--   chunks.
--   
--   <i>Note:</i> as the <tt><a>Monad</a> m</tt> is generic, this is pure
--   transformation.
class FramingRender (strategy :: k)
framingRender :: forall (m :: Type -> Type) a. (FramingRender strategy, Monad m) => Proxy strategy -> (a -> ByteString) -> SourceT m a -> SourceT m ByteString

-- | The <a>FramingUnrender</a> class provides the logic for parsing a
--   framing strategy.
class FramingUnrender (strategy :: k)
framingUnrender :: forall (m :: Type -> Type) a. (FramingUnrender strategy, Monad m) => Proxy strategy -> (ByteString -> Either String a) -> SourceT m ByteString -> SourceT m a

-- | A framing strategy that does not do any framing at all, it just passes
--   the input data This will be used most of the time with binary data,
--   such as files
data NoFraming

-- | A simple framing strategy that has no header, and inserts a newline
--   character after each frame. This assumes that it is used with a
--   Content-Type that encodes without newlines (e.g. JSON).
data NewlineFraming

-- | The netstring framing strategy as defined by djb:
--   <a>http://cr.yp.to/proto/netstrings.txt</a>
--   
--   Any string of 8-bit bytes may be encoded as
--   <tt>[len]":"[string]","</tt>. Here <tt>[string]</tt> is the string and
--   <tt>[len]</tt> is a nonempty sequence of ASCII digits giving the
--   length of <tt>[string]</tt> in decimal. The ASCII digits are
--   <tt><a>30</a></tt> for 0, <tt><a>31</a></tt> for 1, and so on up
--   through <tt><a>39</a></tt> for 9. Extra zeros at the front of
--   <tt>[len]</tt> are prohibited: <tt>[len]</tt> begins with
--   <tt><a>30</a></tt> exactly when <tt>[string]</tt> is empty.
--   
--   For example, the string <tt>"hello world!"</tt> is encoded as
--   <tt><a>32 3a 68 65 6c 6c 6f 20 77 6f 72 6c 64 21 2c</a></tt>, i.e.,
--   <tt>"12:hello world!,"</tt>. The empty string is encoded as
--   <tt>"0:,"</tt>.
data NetstringFraming

-- | <a>WithNamedContext</a> names a specific tagged context to use for the
--   combinators in the API. (See also in <tt>servant-server</tt>,
--   <tt>Servant.Server.Context</tt>.) For example:
--   
--   <pre>
--   type UseNamedContextAPI = WithNamedContext "myContext" '[String] (
--       ReqBody '[JSON] Int :&gt; Get '[JSON] Int)
--   </pre>
--   
--   Both the <tt>ReqBody</tt> and <tt>Get</tt> combinators will use the
--   <a>WithNamedContext</a> with type tag "myContext" as their context.
--   
--   <tt>Context</tt>s are only relevant for <tt>servant-server</tt>.
--   
--   For more information, see the tutorial.
data WithNamedContext (name :: Symbol) (subContext :: [Type]) subApi

-- | Flatten API into a list of endpoints.
--   
--   <pre>
--   &gt;&gt;&gt; Refl :: Endpoints SampleAPI :~: '["hello" :&gt; Verb 'GET 200 '[JSON] Int, "bye" :&gt; (Capture "name" String :&gt; Verb 'POST 200 '[JSON, PlainText] Bool)]
--   Refl
--   </pre>
type family Endpoints api :: [Type]

-- | You may use this type family to tell the type checker that your custom
--   type may be skipped as part of a link. This is useful for things like
--   <tt><a>QueryParam</a></tt> that are optional in a URI and do not
--   affect them if they are omitted.
--   
--   <pre>
--   &gt;&gt;&gt; data CustomThing
--   
--   &gt;&gt;&gt; type instance IsElem' e (CustomThing :&gt; s) = IsElem e s
--   </pre>
--   
--   Note that <tt><a>IsElem</a></tt> is called, which will mutually
--   recurse back to <tt><a>IsElem'</a></tt> if it exhausts all other
--   options again.
--   
--   Once you have written a <tt>HasLink</tt> instance for
--   <tt>CustomThing</tt> you are ready to go.
type family IsElem' a s

-- | Closed type family, check if <tt>endpoint</tt> is within <tt>api</tt>.
--   Uses <tt><a>IsElem'</a></tt> if it exhausts all other options.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem ("hello" :&gt; Get '[JSON] Int) SampleAPI))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem ("bye" :&gt; Get '[JSON] Int) SampleAPI))
--   ...
--   ... Could not deduce...
--   ...
--   </pre>
--   
--   An endpoint is considered within an api even if it is missing
--   combinators that don't affect the URL:
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem (Get '[JSON] Int) (Header "h" Bool :&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem (Get '[JSON] Int) (ReqBody '[JSON] Bool :&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <ul>
--   <li>N.B.:* <tt>IsElem a b</tt> can be seen as capturing the notion of
--   whether the URL represented by <tt>a</tt> would match the URL
--   represented by <tt>b</tt>, *not* whether a request represented by
--   <tt>a</tt> matches the endpoints serving <tt>b</tt> (for the latter,
--   use <a>IsIn</a>).</li>
--   </ul>
type family IsElem endpoint api

-- | Check whether <tt>sub</tt> is a sub-API of <tt>api</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsSubAPI SampleAPI (SampleAPI :&lt;|&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsSubAPI (SampleAPI :&lt;|&gt; Get '[JSON] Int) SampleAPI))
--   ...
--   ... Could not deduce...
--   ...
--   </pre>
--   
--   This uses <tt>IsElem</tt> for checking; thus the note there applies
--   here.
type family IsSubAPI sub api

-- | Check that every element of <tt>xs</tt> is an endpoint of <tt>api</tt>
--   (using <tt><a>IsElem</a></tt>).
type family AllIsElem (xs :: [Type]) api

-- | Closed type family, check if <tt>endpoint</tt> is exactly within
--   <tt>api</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsIn ("hello" :&gt; Get '[JSON] Int) SampleAPI))
--   OK
--   </pre>
--   
--   Unlike <a>IsElem</a>, this requires an *exact* match.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsIn (Get '[JSON] Int) (Header "h" Bool :&gt; Get '[JSON] Int)))
--   ...
--   ... Could not deduce...
--   ...
--   </pre>
type family IsIn endpoint api

-- | Check whether <tt>sub</tt> is a sub API of <tt>api</tt>.
--   
--   Like <a>IsSubAPI</a>, but uses <a>IsIn</a> rather than <a>IsElem</a>.
type family IsStrictSubAPI sub api

-- | Check that every element of <tt>xs</tt> is an endpoint of <tt>api</tt>
--   (using <tt><a>IsIn</a></tt>).
--   
--   ok (Proxy :: Proxy (AllIsIn (Endpoints SampleAPI) SampleAPI)) OK
type family AllIsIn (xs :: [Type]) api

-- | Apply <tt>(e :&gt;)</tt> to every API in <tt>xs</tt>.
type family MapSub (e :: k) (xs :: [Type]) :: [Type]

-- | Append two type-level lists.
type family AppendList (xs :: [a]) (ys :: [a]) :: [a]
type family IsSubList (a :: [t]) (b :: [t])

-- | Check that a value is an element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (Elem Bool '[Int, Bool]))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (Elem String '[Int, Bool]))
--   ...
--   ... [Char]...'[Int, Bool...
--   ...
--   </pre>
type Elem (e :: t) (es :: [t]) = ElemGo e es es
type family ElemGo (e :: t) (es :: [t]) (orig :: t1)

-- | If either a or b produce an empty constraint, produce an empty
--   constraint.
type family Or a b

-- | If both a or b produce an empty constraint, produce an empty
--   constraint.
type family And a b

-- | <tt>Verb</tt> is a general type for representing HTTP verbs (a.k.a.
--   methods). For convenience, type synonyms for each verb with a 200
--   response code are provided, but you are free to define your own:
--   
--   <pre>
--   &gt;&gt;&gt; type Post204 contentTypes a = Verb 'POST 204 contentTypes a
--   </pre>
data Verb (method :: k1) (statusCode :: Nat) (contentTypes :: [Type]) a

-- | <a>GET</a> with 200 status code.
type Get = Verb 'GET 200

-- | <a>POST</a> with 200 status code.
type Post = Verb 'POST 200

-- | <a>PUT</a> with 200 status code.
type Put = Verb 'PUT 200

-- | <a>DELETE</a> with 200 status code.
type Delete = Verb 'DELETE 200

-- | <a>PATCH</a> with 200 status code.
type Patch = Verb 'PATCH 200

-- | <a>POST</a> with 201 status code.
type PostCreated = Verb 'POST 201

-- | <a>PUT</a> with 201 status code.
type PutCreated = Verb 'PUT 201

-- | <a>GET</a> with 202 status code.
type GetAccepted = Verb 'GET 202

-- | <a>POST</a> with 202 status code.
type PostAccepted = Verb 'POST 202

-- | <a>DELETE</a> with 202 status code.
type DeleteAccepted = Verb 'DELETE 202

-- | <a>PATCH</a> with 202 status code.
type PatchAccepted = Verb 'PATCH 202

-- | <a>PUT</a> with 202 status code.
type PutAccepted = Verb 'PUT 202

-- | <a>GET</a> with 203 status code.
type GetNonAuthoritative = Verb 'GET 203

-- | <a>POST</a> with 203 status code.
type PostNonAuthoritative = Verb 'POST 203

-- | <a>DELETE</a> with 203 status code.
type DeleteNonAuthoritative = Verb 'DELETE 203

-- | <a>PATCH</a> with 203 status code.
type PatchNonAuthoritative = Verb 'PATCH 203

-- | <a>PUT</a> with 203 status code.
type PutNonAuthoritative = Verb 'PUT 203

-- | <a>GET</a> with 204 status code.
type GetNoContent = Verb 'GET 204

-- | <a>POST</a> with 204 status code.
type PostNoContent = Verb 'POST 204

-- | <a>DELETE</a> with 204 status code.
type DeleteNoContent = Verb 'DELETE 204

-- | <a>PATCH</a> with 204 status code.
type PatchNoContent = Verb 'PATCH 204

-- | <a>PUT</a> with 204 status code.
type PutNoContent = Verb 'PUT 204

-- | <a>GET</a> with 205 status code.
type GetResetContent = Verb 'GET 205

-- | <a>POST</a> with 205 status code.
type PostResetContent = Verb 'POST 205

-- | <a>GET</a> with 206 status code.
type GetPartialContent = Verb 'GET 206
class ReflectMethod (a :: k)
reflectMethod :: ReflectMethod a => Proxy a -> Method

-- | The contained API (second argument) can be found under <tt>("/" ++
--   path)</tt> (path being the first argument).
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /hello/world
--   
--   &gt;&gt;&gt; -- returning a JSON encoded World value
--   
--   &gt;&gt;&gt; type MyApi = "hello" :&gt; "world" :&gt; Get '[JSON] World
--   </pre>
data (path :: k) :> a
infixr 4 :>

-- | Look up a specific ResponseHeader, without having to know what
--   position it is in the HList.
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String
--   
--   &gt;&gt;&gt; let example2 = addHeader True example1 :: Headers '[Header "1st" Bool, Header "someheader" Int] String
--   
--   &gt;&gt;&gt; lookupResponseHeader example2 :: ResponseHeader "someheader" Int
--   Header 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupResponseHeader example2 :: ResponseHeader "1st" Bool
--   Header True
--   </pre>
--   
--   Usage of this function relies on an explicit type annotation of the
--   header to be looked up. This can be done with type annotations on the
--   result, or with an explicit type application. In this example, the
--   type of header value is determined by the type-inference, we only
--   specify the name of the header:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; case lookupResponseHeader @"1st" example2 of { Header b -&gt; b ; _ -&gt; False }
--   True
--   </pre>
lookupResponseHeader :: forall (h :: Symbol) a (headers :: [Type]) r. HasResponseHeader h a headers => Headers headers r -> ResponseHeader h a

-- | Deliberately do not add a header to a value.
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = noHeader "hi" :: Headers '[Header "someheader" Int] String
--   
--   &gt;&gt;&gt; getHeaders example1
--   []
--   </pre>
noHeader :: forall (h :: Symbol) v orig new. AddHeader h v orig new => orig -> new

-- | <tt>addHeader</tt> adds a header to a response. Note that it changes
--   the type of the value in the following ways:
--   
--   <ol>
--   <li>A simple value is wrapped in "Headers '[hdr]":</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String;
--   
--   &gt;&gt;&gt; getHeaders example1
--   [("someheader","5")]
--   </pre>
--   
--   <ol>
--   <li>A value that already has a header has its new header *prepended*
--   to the existing list:</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String;
--   
--   &gt;&gt;&gt; let example2 = addHeader True example1 :: Headers '[Header "1st" Bool, Header "someheader" Int] String
--   
--   &gt;&gt;&gt; getHeaders example2
--   [("1st","true"),("someheader","5")]
--   </pre>
--   
--   Note that while in your handlers type annotations are not required,
--   since the type can be inferred from the API type, in other cases you
--   may find yourself needing to add annotations.
addHeader :: forall (h :: Symbol) v orig new. AddHeader h v orig new => v -> orig -> new

-- | HList of headers.
getHeadersHList :: Headers ls a -> HList ls
pattern MissingHeader :: () => ResponseHeader sym a
pattern UndecodableHeader :: () => ByteString -> ResponseHeader sym a
data HList (a :: [Type])
[HNil] :: HList ('[] :: [Type])
[HCons] :: forall (h :: Symbol) x (xs :: [Type]). ResponseHeader h x -> HList xs -> HList (Header h x : xs)
class BuildHeadersTo (hs :: [Type])

-- | Note: if there are multiple occurences of a header in the argument,
--   the values are interspersed with commas before deserialization (see
--   <a>RFC2616 Sec 4.2</a>)
buildHeadersTo :: BuildHeadersTo hs => [Header] -> HList hs
class GetHeaders ls
getHeaders :: GetHeaders ls => ls -> [Header]
class AddHeader (h :: Symbol) v orig new | h v orig -> new, new -> h, new -> v, new -> orig
class HasResponseHeader (h :: Symbol) a (headers :: [Type])

-- | Extract the request body as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- POST /books
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book
--   </pre>
type ReqBody = ReqBody' '[Required, Strict]

-- | <i>Note:</i> <a>ReqBody'</a> is always <a>Required</a>.
data ReqBody' (mods :: [Type]) (contentTypes :: [Type]) a

-- | Provides access to the host or IP address from which the HTTP request
--   was sent.
data RemoteHost

-- | Endpoint for plugging in your own Wai <tt>Application</tt>s.
--   
--   The given <tt>Application</tt> will get the request as received by the
--   server, potentially with a modified (stripped) <tt>pathInfo</tt> if
--   the <tt>Application</tt> is being routed with <a>:&gt;</a>.
--   
--   In addition to just letting you plug in your existing WAI
--   <tt>Application</tt>s, this can also be used with
--   <a>serveDirectory</a> to serve static files stored in a particular
--   directory on your filesystem
data Raw

-- | Lookup the value associated to the <tt>sym</tt> query string parameter
--   and try to extract it as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?author=&lt;author name&gt;
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get '[JSON] [Book]
--   </pre>
type QueryParam = QueryParam' '[Optional, Strict]

-- | <a>QueryParam</a> which can be <a>Required</a>, <a>Lenient</a>, or
--   modified otherwise.
data QueryParam' (mods :: [Type]) (sym :: Symbol) a

-- | Lookup the values associated to the <tt>sym</tt> query string
--   parameter and try to extract it as a value of type <tt>[a]</tt>. This
--   is typically meant to support query string parameters of the form
--   <tt>param[]=val1&amp;param[]=val2</tt> and so on. Note that servant
--   doesn't actually require the <tt>[]</tt>s and will fetch the values
--   just fine with <tt>param=val1&amp;param=val2</tt>, too.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?authors[]=&lt;author1&gt;&amp;authors[]=&lt;author2&gt;&amp;...
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get '[JSON] [Book]
--   </pre>
data QueryParams (sym :: Symbol) a

-- | Lookup a potentially value-less query string parameter with boolean
--   semantics. If the param <tt>sym</tt> is there without any value, or if
--   it's there with value "true" or "1", it's interpreted as <a>True</a>.
--   Otherwise, it's interpreted as <a>False</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?published
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get '[JSON] [Book]
--   </pre>
data QueryFlag (sym :: Symbol)
data Header' (mods :: [Type]) (sym :: Symbol) (a :: k)

-- | Required argument. Not wrapped.
data Required

-- | Optional argument. Wrapped in <a>Maybe</a>.
data Optional

-- | Leniently parsed argument, i.e. parsing never fail. Wrapped in
--   <tt><a>Either</a> <a>Text</a></tt>.
data Lenient

-- | Strictly parsed argument. Not wrapped.
data Strict

-- | Was this request made over an SSL connection?
--   
--   Note that this value will not tell you if the client originally made
--   this request over SSL, but rather whether the current connection is
--   SSL. The distinction lies with reverse proxies. In many cases, the
--   client will connect to a load balancer over SSL, but connect to the
--   WAI handler without SSL. In such a case, the handlers would get
--   <a>NotSecure</a>, but from a user perspective, there is a secure
--   connection.
data IsSecure

-- | the connection to the server is secure (HTTPS)
Secure :: IsSecure

-- | the connection to the server is not secure (HTTP)
NotSecure :: IsSecure

-- | A generalized Authentication combinator. Use this if you have a
--   non-standard authentication technique.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE.
data AuthProtect (tag :: k)

-- | An empty API: one which serves nothing. Morally speaking, this should
--   be the unit of <tt>:&lt;|&gt;</tt>. Implementors of interpretations of
--   API types should treat <a>EmptyAPI</a> as close to the unit as
--   possible.
data EmptyAPI
EmptyAPI :: EmptyAPI

-- | Add a short summary for (part of) API.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; type MyApi = Summary "Get book by ISBN." :&gt; "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   </pre>
data Summary (sym :: Symbol)

-- | Add more verbose description for (part of) API.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   type MyApi = Description
--    "This comment is visible in multiple Servant interpretations \
--    \and can be really long if necessary. \
--    \Haskell multiline support is not perfect \
--    \but it's still very readable."
--   :&gt; Get '[JSON] Book
--   :}
--   </pre>
data Description (sym :: Symbol)
data JSON
data PlainText
data FormUrlEncoded
data OctetStream

-- | Instances of <a>Accept</a> represent mimetypes. They are used for
--   matching against the <tt>Accept</tt> HTTP header of the request, and
--   for setting the <tt>Content-Type</tt> header of the response
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media ((//), (/:))
--   
--   &gt;&gt;&gt; data HTML
--   
--   &gt;&gt;&gt; :{
--   instance Accept HTML where
--      contentType _ = "text" // "html" /: ("charset", "utf-8")
--   :}
--   </pre>
class Accept (ctype :: k)
contentType :: Accept ctype => Proxy ctype -> MediaType
contentTypes :: Accept ctype => Proxy ctype -> NonEmpty MediaType

-- | Instantiate this class to register a way of serializing a type based
--   on the <tt>Accept</tt> header.
--   
--   Example:
--   
--   <pre>
--   data MyContentType
--   
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   
--   instance Show a =&gt; MimeRender MyContentType a where
--      mimeRender _ val = pack ("This is MINE! " ++ show val)
--   
--   type MyAPI = "path" :&gt; Get '[MyContentType] Int
--   </pre>
class Accept ctype => MimeRender (ctype :: k) a
mimeRender :: MimeRender ctype a => Proxy ctype -> a -> ByteString

-- | Instantiate this class to register a way of deserializing a type based
--   on the request's <tt>Content-Type</tt> header.
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media hiding (Accept)
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BSC
--   
--   &gt;&gt;&gt; data MyContentType = MyContentType String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Read a =&gt; MimeUnrender MyContentType a where
--      mimeUnrender _ bs = case BSC.take 12 bs of
--        "MyContentType" -&gt; return . read . BSC.unpack $ BSC.drop 12 bs
--        _ -&gt; Left "didn't start with the magic incantation"
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type MyAPI = "path" :&gt; ReqBody '[MyContentType] Int :&gt; Get '[JSON] Int
--   </pre>
class Accept ctype => MimeUnrender (ctype :: k) a
mimeUnrender :: MimeUnrender ctype a => Proxy ctype -> ByteString -> Either String a

-- | Variant which is given the actual <a>MediaType</a> provided by the
--   other party.
--   
--   In the most cases you don't want to branch based on the
--   <a>MediaType</a>. See <a>pr552</a> for a motivating example.
mimeUnrenderWithType :: MimeUnrender ctype a => Proxy ctype -> MediaType -> ByteString -> Either String a

-- | A type for responses without content-body.
data NoContent
NoContent :: NoContent

-- | Capture a value from the request path under a certain type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /books/:isbn
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   </pre>
type Capture = Capture' '[] :: [Type]

-- | <a>Capture</a> which can be modified. For example with
--   <tt>Description</tt>.
data Capture' (mods :: [Type]) (sym :: Symbol) a

-- | Capture all remaining values from the request path under a certain
--   type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /src/*
--   
--   &gt;&gt;&gt; type MyAPI = "src" :&gt; CaptureAll "segments" Text :&gt; Get '[JSON] SourceFile
--   </pre>
data CaptureAll (sym :: Symbol) a

-- | Combinator for <a>Basic Access Authentication</a>.
--   
--   <ul>
--   <li>IMPORTANT*: Only use Basic Auth over HTTPS! Credentials are not
--   hashed or encrypted. Note also that because the same credentials are
--   sent on every request, Basic Auth is not as secure as some
--   alternatives. Further, the implementation in servant-server does not
--   protect against some types of timing attacks.</li>
--   </ul>
--   
--   In Basic Auth, username and password are base64-encoded and
--   transmitted via the <tt>Authorization</tt> header. Handshakes are not
--   required, making it relatively efficient.
data BasicAuth (realm :: Symbol) userData

-- | A simple datatype to hold data required to decorate a request
data BasicAuthData
BasicAuthData :: !ByteString -> !ByteString -> BasicAuthData
[basicAuthUsername] :: BasicAuthData -> !ByteString
[basicAuthPassword] :: BasicAuthData -> !ByteString

-- | Union of two APIs, first takes precedence in case of overlap.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--          :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] () -- POST /books
--   :}
--   </pre>
data a :<|> b
(:<|>) :: a -> b -> (:<|>) a b
infixr 3 :<|>
infixr 3 :<|>

-- | A persistent store for values of arbitrary types.
--   
--   This variant is the simplest and creates keys in the <a>IO</a> monad.
--   See the module <a>Data.Vault.ST</a> if you want to use it with the
--   <a>ST</a> monad instead.
type Vault = Vault RealWorld
class SBoolI (b :: Bool)
sbool :: SBoolI b => SBool b
data SBool (b :: Bool)
[STrue] :: SBool 'True
[SFalse] :: SBool 'False

-- | Time of day as represented in hour, minute and second (with
--   picoseconds), typically used to express local time of day.
data TimeOfDay

-- | The Modified Julian Day is a standard count of days, with zero being
--   the day 1858-11-17.
data Day
newtype Textual a
Textual :: a -> Textual a
type JSONValue = Value
parseJSONObject :: FromJSON a => HashMap Text Value -> Parser a
parseJSONText :: FromHttpApiData a => String -> Value -> Parser a
toJSONText :: ToHttpApiData a => a -> Value

-- | Binary data.
--   
--   This data is passed to/from the serialisation routines as-is, and any
--   particular encoding or decoding (say, base64) is left up to the
--   caller.
newtype Bytes
Bytes :: ByteString -> Bytes
[unBytes] :: Bytes -> ByteString
_Bytes :: Iso' Bytes ByteString
newtype Nat
Nat :: Natural -> Nat
[unNat] :: Nat -> Natural

-- | A duration in seconds with up to nine fractional digits, terminated by
--   <tt>s</tt>.
--   
--   <i>Example</i>: <tt>"3.5s"</tt>.
data GDuration

-- | This SHOULD be a date in ISO 8601 format of YYYY-MM- DDThh:mm:ssZ in
--   UTC time. This is the recommended form of date/timestamp.
newtype DateTime'
DateTime' :: UTCTime -> DateTime'
[unDateTime] :: DateTime' -> UTCTime

-- | This SHOULD be a date in the format of YYYY-MM-DD. It is recommended
--   that you use the "date-time" format instead of "date" unless you need
--   to transfer only the date part.
data Date'

-- | This SHOULD be a time in the format of hh:mm:ss. It is recommended
--   that you use the "date-time" format instead of "time" unless you need
--   to transfer only the time part.
data Time'
_Time :: Iso' Time' TimeOfDay
_Date :: Iso' Date' Day
_DateTime :: Iso' DateTime' UTCTime
_GDuration :: Iso' GDuration Scientific
newtype GFieldMask
GFieldMask :: Text -> GFieldMask

-- | An integral value representing seconds.
newtype Seconds
Seconds :: Int -> Seconds
data MultipartRelated (cs :: [*]) m

-- | Form a Google style sub-resource, such as
--   <tt>/<a>capture</a>:<a>mode</a></tt>.
data CaptureMode (s :: Symbol) (m :: Symbol) a

-- | Multiple path captures, with <tt>[xs]</tt> forming
--   <tt><i><a>x1</a></i><a>x2</a><i><a>x2</a></i>...</tt>.
data Captures (s :: Symbol) a
class GoogleClient fn where {
    type family Fn fn :: *;
}
buildClient :: GoogleClient fn => Proxy fn -> Request -> Fn fn
class GoogleRequest a where {
    type family Rs a :: *;
    type family Scopes a :: [Symbol];
}
requestClient :: GoogleRequest a => a -> GClient (Rs a)
class Accept c => FromStream c a
fromStream :: FromStream c a => Proxy c -> Stream -> ResourceT IO (Either (String, ByteString) a)
class Accept c => ToBody c a
toBody :: ToBody c a => Proxy c -> a -> GBody

-- | A materialised 'http-client' request and associated response parser.
data GClient a
GClient :: !Maybe MediaType -> !Method -> !Status -> Bool -> !ServiceConfig -> !Request -> !Stream -> ResourceT IO (Either (String, ByteString) a) -> GClient a
[_cliAccept] :: GClient a -> !Maybe MediaType
[_cliMethod] :: GClient a -> !Method
[_cliCheck] :: GClient a -> !Status -> Bool
[_cliService] :: GClient a -> !ServiceConfig
[_cliRequest] :: GClient a -> !Request
[_cliResponse] :: GClient a -> !Stream -> ResourceT IO (Either (String, ByteString) a)

-- | An intermediary request builder.
data Request
Request :: !Builder -> !DList (ByteString, Maybe ByteString) -> !DList (HeaderName, ByteString) -> ![GBody] -> Request
[_rqPath] :: Request -> !Builder
[_rqQuery] :: Request -> !DList (ByteString, Maybe ByteString)
[_rqHeaders] :: Request -> !DList (HeaderName, ByteString)
[_rqBody] :: Request -> ![GBody]

-- | A single part of a (potentially multipart) request body.
--   
--   <i>Note:</i> The <a>IsString</a> instance defaults to a
--   <tt>text/plain</tt> MIME type.
data GBody
GBody :: !MediaType -> !RequestBody -> GBody
data ServiceConfig
ServiceConfig :: !ServiceId -> !ByteString -> !Builder -> !Int -> !Bool -> !Maybe Seconds -> ServiceConfig
[_svcId] :: ServiceConfig -> !ServiceId
[_svcHost] :: ServiceConfig -> !ByteString
[_svcPath] :: ServiceConfig -> !Builder
[_svcPort] :: ServiceConfig -> !Int
[_svcSecure] :: ServiceConfig -> !Bool
[_svcTimeout] :: ServiceConfig -> !Maybe Seconds
class AsError a

-- | A general Amazonka error.
_Error :: AsError a => Prism' a Error

-- | An error occured while communicating over HTTP with a remote service.
_TransportError :: AsError a => Prism' a HttpException

-- | A serialisation error occured when attempting to deserialise a
--   response.
_SerializeError :: AsError a => Prism' a SerializeError

-- | A service specific error returned by the remote service.
_ServiceError :: AsError a => Prism' a ServiceError
data ServiceError
ServiceError' :: !ServiceId -> !Status -> ![Header] -> !Maybe ByteString -> ServiceError
[_serviceId] :: ServiceError -> !ServiceId
[_serviceStatus] :: ServiceError -> !Status
[_serviceHeaders] :: ServiceError -> ![Header]
[_serviceBody] :: ServiceError -> !Maybe ByteString
data SerializeError
SerializeError' :: !ServiceId -> [Header] -> !Status -> !String -> !Maybe ByteString -> SerializeError
[_serializeId] :: SerializeError -> !ServiceId
[_serializeHeaders] :: SerializeError -> [Header]
[_serializeStatus] :: SerializeError -> !Status
[_serializeMessage] :: SerializeError -> !String
[_serializeBody] :: SerializeError -> !Maybe ByteString
data Error
TransportError :: HttpException -> Error
SerializeError :: SerializeError -> Error
ServiceError :: ServiceError -> Error
type Stream = ConduitM () ByteString (ResourceT IO) ()
data MediaUpload a
MediaUpload :: a -> GBody -> MediaUpload a
newtype MediaDownload a
MediaDownload :: a -> MediaDownload a

-- | An opaque client secret.
newtype GSecret
GSecret :: Text -> GSecret

-- | A service identifier.
newtype ServiceId
ServiceId :: Text -> ServiceId

-- | A client identifier.
newtype ClientId
ClientId :: Text -> ClientId

-- | An OAuth2 refresh token.
newtype RefreshToken
RefreshToken :: Text -> RefreshToken

-- | An OAuth2 access token.
newtype AccessToken
AccessToken :: Text -> AccessToken

-- | An OAuth2 scope.
newtype OAuthScope
OAuthScope :: Text -> OAuthScope
data Multipart
Multipart :: Multipart
data AltMedia
AltMedia :: AltMedia
data AltJSON
AltJSON :: AltJSON
_Coerce :: (Coercible a b, Coercible b a) => Iso' a b

-- | Invalid Iso, exists for ease of composition with the current 'Lens .
--   Iso' chaining to hide internal types from the user.
_Default :: Monoid a => Iso' (Maybe a) a
defaultService :: ServiceId -> ByteString -> ServiceConfig

-- | The remote host name, used for both the IP address to connect to and
--   the host request header.
serviceHost :: Lens' ServiceConfig ByteString

-- | The remote port to connect to.
--   
--   Defaults to <tt>443</tt>.
servicePort :: Lens' ServiceConfig Int

-- | A path prefix that is prepended to any sent HTTP request.
--   
--   Defaults to <tt>mempty</tt>.
servicePath :: Lens' ServiceConfig Builder

-- | Whether to use HTTPS/SSL.
--   
--   Defaults to <tt>True</tt>.
serviceSecure :: Lens' ServiceConfig Bool

-- | Number of seconds to wait for a response.
serviceTimeout :: Lens' ServiceConfig (Maybe Seconds)

-- | A lens into the <a>MediaType</a> of a request <tt>Body</tt>.
bodyContentType :: Lens' GBody MediaType
appendPath :: Request -> Builder -> Request
appendPaths :: ToHttpApiData a => Request -> [a] -> Request
appendQuery :: Request -> ByteString -> Maybe Text -> Request
appendHeader :: Request -> HeaderName -> Maybe Text -> Request
setBody :: Request -> [GBody] -> Request
clientService :: Lens' (GClient a) ServiceConfig
mime :: FromStream c a => Proxy c -> Method -> [Int] -> Request -> ServiceConfig -> GClient a
discard :: Method -> [Int] -> Request -> ServiceConfig -> GClient ()
gClient :: (Stream -> ResourceT IO (Either (String, ByteString) a)) -> Maybe MediaType -> Method -> [Int] -> Request -> ServiceConfig -> GClient a
sinkLBS :: Stream -> ResourceT IO ByteString
buildText :: ToHttpApiData a => a -> Builder
buildSymbol :: forall n proxy. KnownSymbol n => proxy n -> Builder
byteSymbol :: forall n proxy. KnownSymbol n => proxy n -> ByteString
seconds :: Seconds -> Int
microseconds :: Seconds -> Int
